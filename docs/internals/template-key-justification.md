# Template Key Justification
The following describes how i18n keys are justified in a html source file:

+ Traverse the parsed html tree:
	+ if a node is whitelisted,
		+ raise diagnostic if node contains mixed content (tags and non-whitespace text).
		+ try parsing the original i18n attribute and add to the list of known keys.
	+ else
		+ raise diagnostic if node contains non-whitespace text
		+ raise diagnostic if node has an i18n attribute.
+ Start a new postfix counter at zero.
+ Function for generating a unique i18n key (with an optional original key):
	+ if no key is provided or a similar key has been generated by this function,
		+ generate new keys until it is not in the list of known keys.
	+ add the key to the list of known keys.
	+ add the key to the list of keys generated by this function.
	+ return the key.
+ For all whitelisted nodes from the tree traversal:
	+ create a new i18n attribute.
	+ if content localization is allowed,
		+ get the preferred key from the original attribute.
		+ if the node has text content or the preferred key exists,
			+ generate and store a unique key in the new i18n attribute.
	+ else, if the original attribute has a key for html or text content
		+ raise diagnostic that already localized content is not allowed
	+ else, if the node has text content
		+ raise diagnostic that content is not allowed
	+ for each whitelisted attribute name that exists:
		+ get the preferred key from the original attribute.
		+ generate and store a unique key in the new attribute.
	+ for each attribute name (non text/html) in the original key:
		+ raise diagnostic if the name is not whitelisted.
	+ if the new i18n attribute is empty, delete the original attribute
	+ else, set replace the original attribute.

## Additional notes
+ Html attributes named `"html"` or `"text"` are ignored due to the way aurelia-i18n works.
